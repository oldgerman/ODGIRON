/*
 * oled_init.cpp
 *
 *  Created on: Jan 17, 2021
 *      Author: 29209
 */


#include "oled_init.h"
#include "main.h"
#ifndef ODGIRON_BOOTLDR
#include "cmsis_os.h"
#endif
U8G2_SSD1306_128X32_UNIVISION_HW_I2C u8g2(U8G2_R0);


const uint8_t startLogo[] = { 0x78, 0x1E, 0xE0, 0xF3, 0x01, 0x78, 0x00, 0xE0,
		0x83, 0xCF, 0x07, 0x80, 0xE7, 0x01, 0x0E, 0x78, 0x3C, 0x3C, 0xE0, 0xC3,
		0x03, 0x3C, 0x00, 0xE0, 0x83, 0x0F, 0x0F, 0xC0, 0xC3, 0x03, 0x0E, 0x60,
		0x1E, 0x78, 0xE0, 0x83, 0x07, 0x1E, 0x40, 0xE0, 0x83, 0x0F, 0x1E, 0xE0,
		0x81, 0x07, 0x1E, 0x40, 0x1E, 0x78, 0xE0, 0x83, 0x07, 0x1E, 0xF0, 0xE0,
		0x83, 0x0F, 0x1E, 0xE0, 0x81, 0x07, 0x1E, 0x40, 0x1F, 0xF8, 0xE0, 0x83,
		0x07, 0x1F, 0xF0, 0xE0, 0x83, 0x0F, 0x1E, 0xF0, 0x81, 0x0F, 0x3E, 0x00,
		0x1F, 0xF8, 0xE0, 0x83, 0x07, 0x1F, 0xF0, 0xE0, 0x83, 0x0F, 0x1E, 0xF0,
		0x81, 0x0F, 0x7C, 0x00, 0x1F, 0xF8, 0xE0, 0x83, 0x07, 0x1F, 0x60, 0xE0,
		0x83, 0x0F, 0x1E, 0xF0, 0x81, 0x0F, 0x78, 0x00, 0x1F, 0xF8, 0xE0, 0x83,
		0x07, 0x1F, 0x00, 0xE0, 0x83, 0x0F, 0x1E, 0xF0, 0x81, 0x0F, 0xF8, 0x00,
		0x1F, 0xF8, 0xE0, 0x83, 0x07, 0x1F, 0x00, 0xE0, 0x83, 0x0F, 0x0F, 0xF0,
		0x81, 0x0F, 0xF0, 0x00, 0x1F, 0xF8, 0xE0, 0x83, 0x07, 0x1F, 0x00, 0xE0,
		0x83, 0x8F, 0x07, 0xF0, 0x81, 0x0F, 0xF0, 0x01, 0x1F, 0xF8, 0xE0, 0x83,
		0x07, 0x1F, 0xFE, 0xE0, 0x83, 0xCF, 0x03, 0xF0, 0x81, 0x0F, 0xE0, 0x01,
		0x1F, 0xF8, 0xE0, 0x83, 0x07, 0x1F, 0xF0, 0xE0, 0x83, 0x0F, 0x0F, 0xF0,
		0x81, 0x0F, 0xE0, 0x03, 0x1F, 0xF8, 0xE0, 0x83, 0x07, 0x1F, 0xF0, 0xE0,
		0x83, 0x0F, 0x0F, 0xF0, 0x81, 0x0F, 0xC0, 0x03, 0x1F, 0xF8, 0xE0, 0x83,
		0x07, 0x1F, 0xF0, 0xE0, 0x83, 0x0F, 0x0F, 0xF0, 0x81, 0x0F, 0xC0, 0x07,
		0x1F, 0xF8, 0xE0, 0x83, 0x07, 0x1F, 0xF0, 0xE0, 0x83, 0x0F, 0x1F, 0xF0,
		0x81, 0x0F, 0x80, 0x0F, 0x1F, 0xF8, 0xE0, 0x83, 0x07, 0x1F, 0xF0, 0xE0,
		0x83, 0x0F, 0x1F, 0xF0, 0x81, 0x0F, 0x00, 0x0F, 0x1E, 0x78, 0xE0, 0x83,
		0x07, 0x1E, 0xF0, 0xE0, 0x83, 0x0F, 0x1F, 0xE0, 0x81, 0x07, 0x02, 0x1F,
		0x1E, 0x78, 0xE0, 0x83, 0x07, 0x1E, 0xF0, 0xE0, 0x83, 0x0F, 0x1F, 0xE0,
		0x81, 0x07, 0x02, 0x1E, 0x3C, 0x3C, 0xE0, 0xC3, 0x03, 0x3C, 0x78, 0xE0,
		0x83, 0x0F, 0x1E, 0xC0, 0xC3, 0x03, 0x06, 0x3E, 0x78, 0x1E, 0xE0, 0xF3,
		0x01, 0x78, 0x3C, 0xE0, 0x83, 0x0F, 0x7C, 0x80, 0xE7, 0x01, 0x3E, 0x7C,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x10, 0xF8, 0x47, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xFF, 0x49, 0xF4, 0x1F, 0x04, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x44, 0xF8, 0xE7, 0x8E,
		0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xFF, 0x49, 0x54, 0x95, 0x3C, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x29, 0x49, 0xE4, 0x8F, 0x04, 0x04, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC7, 0xF9, 0x07, 0x80,
		0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x7D, 0x49, 0xF4, 0x9F, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x45, 0x45, 0x24, 0x89, 0x04, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBD, 0x45, 0x96, 0xD1,
		0x7F, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};


#include "stdio.h"
#include "dtostrf.h"
#include "stdlib.h"	//提供atoi()
#include <cstring>


/**
 * C 从__DATE__宏获取编译日期函数,有修改
 * https://www.cnblogs.com/oyjj/archive/2011/04/24/2132874.html
 * 依赖：string.h
 */

typedef struct tagXDate {
	int year;
	int month;
	int day;
} XDate;

XDate compileXDate;	//编译日期决定版本号后3组XX数字："v1.0.XX.XX.XX"

bool GetCompileDate(XDate *date) {
	bool succeed = true;
	char complieDate[] = { __DATE__ };	//"Jul 06 2021"
	//字符串长度，可使用strlen()函数直接求出，切记，在使用strlen()求出字符串长度时，勿忘+1

	/**
	 strtok、strtok_s、strtok_r 字符串分割函数
	 https://blog.csdn.net/hustfoxy/article/details/23473805
	 */
	char *ptr;
	ptr = strtok(complieDate, " ");
	char *month = ptr;
	ptr = strtok(nullptr, " ");
	char *day = ptr;
	ptr = strtok(nullptr, " ");
	char *yearNoIntercept = ptr;	//未截取的年分：4位
	char year[3] = { 0 };					//储存截取年份的后2位
	/*
	 * C语言截取从某位置开始指定长度子字符串方法
	 * https://blog.csdn.net/zmhawk/article/details/44600075
	 */
	strncpy(year, yearNoIntercept + 2, 2);	//截取年后两位
	ptr = strtok(nullptr, " ");
	date->day = atoi(day);	//atoi()函数：将字符串转换成int(整数)
	if (date->day == 0)
		succeed = false;
	date->year = atoi(year);	//atoi()函数：将字符串转换成int(整数)
	if (date->year == 0)
		succeed = false;
	//依次判断月份
	const char months[][4] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
			"Aug", "Sep", "Oct", "Nov", "Dec" };
	date->month = 0;
	for (int i = 0; i < 12; i++) {
		if (strcmp(month, months[i]) == 0) {
			date->month = i + 1;
			break;
		}
	}
	if (date->month == 0)
		succeed = false;
	return succeed;
}

void drawLogoAndVersion(char firmwareMark)
{
	//第一页
	u8g2.drawXBM(0, 0, 128, 32, startLogo);
	u8g2.setFont(u8g2_font_IPAandRUSLCD_tf); //7pixel字体;

	char buf[18] { 0 };	//"v1.0.21.06.12"; 固定13个可打印字符
	if (GetCompileDate(&compileXDate)) {
		snprintf(buf, sizeof(buf), "(%c)v1.0.%02d.%02d.%02d", firmwareMark, compileXDate.year,
				compileXDate.month, compileXDate.day);
	} else {
		snprintf(buf, sizeof(buf), "(%c)v1.0.XX.XX.XX", firmwareMark);
	}
	uint8_t x = OLED_WIDTH - strlen(buf) * 5/*5=字体宽度*/- 2/*计算失误的偏差*/;	//版本号右对齐
	u8g2.drawStr(x, 24, buf);
}



#ifdef OLED_I2C_NONE_DMA
uint8_t u8x8_byte_hw_i2c(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
	/* u8g2/u8x8 will never send more than 32 bytes between START_TRANSFER and END_TRANSFER */
	static uint8_t buffer[32];
	static uint8_t buf_idx;
	uint8_t *data;

	switch(msg)
	{
	case U8X8_MSG_BYTE_SEND:
		data = (uint8_t *)arg_ptr;
		while( arg_int > 0 )
		{
			buffer[buf_idx++] = *data;
			data++;
			arg_int--;
		}
		break;
	case U8X8_MSG_BYTE_INIT:
		/* add your custom code to init i2c subsystem */
		break;
	case U8X8_MSG_BYTE_SET_DC:
		break;
	case U8X8_MSG_BYTE_START_TRANSFER:
		buf_idx = 0;
		break;
	case U8X8_MSG_BYTE_END_TRANSFER:
		if(HAL_I2C_Master_Transmit(&hi2c1, (DEVICE_ADDRESS << 1), buffer, buf_idx, TX_TIMEOUT) != HAL_OK) return 0;
		break;
	default:
		return 0;
	}
	return 1;
}
#endif

uint8_t u8x8_gpio_and_delay(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
	/* STM32 supports HW SPI, Remove unused cases like U8X8_MSG_DELAY_XXX & U8X8_MSG_GPIO_XXX */
	switch(msg)
	{
	case U8X8_MSG_GPIO_AND_DELAY_INIT:
		/* Insert codes for initialization */
		break;
	case U8X8_MSG_DELAY_MILLI:
		/* ms Delay */
		//HAL_Delay(arg_int);
		HAL_Delay(1);
		break;
	}
	return 1;
}

void u8g2Init(u8g2_t *u8g2)
{
#ifdef OLED_I2C_NONE_DMA
    u8g2_Setup_ssd1306_i2c_128x64_noname_f(u8g2, U8G2_R0, u8x8_byte_hw_i2c, u8x8_gpio_and_delay); // 初始化 u8g2 结构体
#endif

#ifdef OLED_I2C_WITH_DMA
	//u8g2_Setup_ssd1306_i2c_128x64_noname_f(u8g2, U8G2_R0, u8x8_byte_stm32hal_hw_i2c_dma, u8x8_gpio_and_delay); // 初始化 u8g2 结构体
    //u8g2_Setup_ssd1316_128x32_1(u8g2, U8G2_R0, u8x8_byte_stm32hal_hw_i2c_dma, u8x8_gpio_and_delay);

    #endif

	u8g2_InitDisplay(u8g2);                                                                       // 根据所选的芯片进行初始化工作，初始化完成后，显示器处于关闭状态
    u8g2_SetPowerSave(u8g2, 0);                                                                   // 打开显示器
    u8g2_ClearBuffer(u8g2);
}

void u8g2_begin(){
	u8g2.begin();
}

#if 1
//https://qiita.com/tlab/items/e62d76a23a1496654e09
uint8_t u8x8_byte_stm32hal_hw_i2c_dma(u8x8_t *u8x8, uint8_t msg, uint8_t arg_int, void *arg_ptr)
{
    static uint8_t buffer[32];      /* u8g2/u8x8 will never send more than 32 bytes between START_TRANSFER and END_TRANSFER */
    static uint8_t buf_idx;
    uint8_t *data;

    //usb_printf("msg = %d   " , msg);
  switch(msg)
  {
    case U8X8_MSG_BYTE_SEND:
    {
        data = (uint8_t *)arg_ptr;
        while( arg_int > 0 )
        {
            buffer[buf_idx++] = *data;
            data++;
            arg_int--;
        }
    }
        break;
    case U8X8_MSG_BYTE_INIT:
        break;
    case U8X8_MSG_BYTE_SET_DC:
        break;
    case U8X8_MSG_BYTE_START_TRANSFER:
        {
            buf_idx = 0;
        }
        break;
    case U8X8_MSG_BYTE_END_TRANSFER:
    {
        uint8_t iaddress = DEVICE_ADDRESS;	//0x3c
        //usb_printf("buf_indx = %d\r\n", buf_idx);
      if(HAL_I2C_Master_Transmit_DMA(&hi2c1, (uint16_t)iaddress<<1, &buffer[0], buf_idx)!= HAL_OK)
    	  return 0;
#ifndef ODGIRON_BOOTLDR
      osDelay(1);
#else
       HAL_Delay(3);
#endif


    }
        break;
    default:
      return 0;
  }
  return 1;
}

#endif
